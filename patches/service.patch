--- pkg/mod/github.com/fatedier/frp@v0.39.1/client/service.go	2022-02-07 09:18:00.000000000 +0800
+++ patches/service.go	2022-02-07 10:12:45.000000000 +0800
@@ -20,12 +20,13 @@
 	"errors"
 	"fmt"
 	"io"
 	"net"
 	"runtime"
 	"strconv"
+	"strings"
 	"sync"
 	"sync/atomic"
 	"time"

 	"github.com/fatedier/frp/assets"
 	"github.com/fatedier/frp/pkg/auth"
@@ -34,12 +35,13 @@
 	"github.com/fatedier/frp/pkg/transport"
 	"github.com/fatedier/frp/pkg/util/log"
 	frpNet "github.com/fatedier/frp/pkg/util/net"
 	"github.com/fatedier/frp/pkg/util/version"
 	"github.com/fatedier/frp/pkg/util/xlog"
 	libdial "github.com/fatedier/golib/net/dial"
+	"github.com/miekg/dns"

 	fmux "github.com/hashicorp/yamux"
 )

 // Service is a client service.
 type Service struct {
@@ -203,12 +205,50 @@
 			svr.ctlMu.Unlock()
 			break
 		}
 	}
 }

+func lookupIP(addr string, server string) (string, error) {
+	if net.ParseIP(addr) != nil {
+		return addr, nil
+	}
+	c := dns.Client{}
+	m := dns.Msg{}
+	if !strings.HasSuffix(addr, ".") {
+		addr += "."
+	}
+	if !strings.Contains(server, ":") {
+		server += ":53"
+	}
+	m.SetQuestion(addr, dns.TypeA)
+	r, _, err := c.Exchange(&m, server)
+	if err != nil {
+		return "", err
+	}
+	if len(r.Answer) == 0 {
+		m.SetQuestion(addr, dns.TypeAAAA)
+		if r, _, err = c.Exchange(&m, server); err != nil {
+			return "", err
+		}
+		if len(r.Answer) == 0 {
+			return "", errors.New(fmt.Sprintf("no record for host '%s' with '%s'", addr, server))
+		}
+	}
+	switch v := r.Answer[0].(type) {
+	case *dns.A:
+		return v.A.String(), nil
+	case *dns.AAAA:
+		return v.AAAA.String(), nil
+	case *dns.CNAME:
+		return lookupIP(v.Target, server)
+	default:
+		return "", errors.New(fmt.Sprintf("host '%s' lookup failed with '%s'", addr, server))
+	}
+}
+
 // login creates a connection to frps and registers it self as a client
 // conn: control connection
 // session: if it's not nil, using tcp mux
 func (svr *Service) login() (conn net.Conn, session *fmux.Session, err error) {
 	xl := xlog.FromContextSafe(svr.ctx)
 	var tlsConfig *tls.Config
@@ -249,14 +289,20 @@
 		libdial.WithProxyAuth(auth),
 		libdial.WithTLSConfig(tlsConfig),
 		libdial.WithAfterHook(libdial.AfterHook{
 			Hook: frpNet.DialHookCustomTLSHeadByte(tlsConfig != nil, svr.cfg.DisableCustomTLSFirstByte),
 		}),
 	)
+	var serverAddr = svr.cfg.ServerAddr
+	if svr.cfg.DNSServer != "" && runtime.GOOS == "windows" {
+		if serverAddr, err = lookupIP(svr.cfg.ServerAddr, svr.cfg.DNSServer); err != nil {
+			return nil, nil, err
+		}
+	}
 	conn, err = libdial.Dial(
-		net.JoinHostPort(svr.cfg.ServerAddr, strconv.Itoa(svr.cfg.ServerPort)),
+		net.JoinHostPort(serverAddr, strconv.Itoa(svr.cfg.ServerPort)),
 		dialOptions...,
 	)
 	if err != nil {
 		return
 	}

